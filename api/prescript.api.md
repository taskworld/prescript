## API Report File for "prescript"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

/// <reference types="node" />

// @public
export function action(name: string, f: ActionFunction): void;

// @public
export function action(nameParts: TemplateStringsArray, ...substitutions: any[]): (f?: ActionFunction) => void;

// @public @deprecated
export function action(f: ActionFunction): void;

// @public (undocumented)
export type ActionFunction = (state: Prescript.GlobalState, context: ITestExecutionContext) => void | Thenable;

// Warning: (ae-incompatible-release-tags) The symbol "ActionWrapper" is marked as @public, but its signature references "IStep" which is marked as @internal
//
// @public (undocumented)
export type ActionWrapper = (step: IStep, execute: () => Promise<void>, state: Prescript.GlobalState, context: ITestExecutionContext) => Promise<void>;

// Warning: (ae-incompatible-release-tags) The symbol "cleanup" is marked as @public, but its signature references "StepDefName" which is marked as @internal
//
// @public @deprecated
export function cleanup<X>(name: StepDefName, f: () => X): X;

// @public (undocumented)
const _default: {
    test: typeof test_2;
    to: typeof to;
    action: typeof action;
    defer: typeof defer;
    pending: typeof pending_2;
    step: typeof step;
    cleanup: typeof cleanup;
    onFinish: typeof onFinish;
    getCurrentState: typeof getCurrentState;
    getCurrentContext: typeof getCurrentContext;
    getCurrentPrescriptionState: typeof getCurrentPrescriptionState;
};
export default _default;

// @public
export function defer(name: string, f: ActionFunction): void;

// @public
export function defer(nameParts: TemplateStringsArray, ...substitutions: any[]): (f?: ActionFunction) => void;

// @public
export function getCurrentContext(): ITestExecutionContext;

// @public
export function getCurrentPrescriptionState(): Prescript.PrescriptionState;

// @public
export function getCurrentState(): Prescript.GlobalState;

// @public
export interface IConfig {
    wrapAction?: ActionWrapper;
}

// @public
export function independent<X>(f: () => X): X;

// Warning: (ae-internal-missing-underscore) The name "IStep" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export interface IStep {
    // (undocumented)
    action?: ActionFunction;
    // (undocumented)
    actionDefinition?: string;
    // (undocumented)
    children?: IStep[];
    // (undocumented)
    cleanup?: boolean;
    // (undocumented)
    creator?: string;
    // (undocumented)
    defer?: boolean;
    // (undocumented)
    definition?: string;
    // (undocumented)
    independent?: boolean;
    // (undocumented)
    name: StepName;
    // (undocumented)
    number?: string;
    // (undocumented)
    pending?: boolean;
}

// @public (undocumented)
export interface ITestExecutionContext {
    attach(name: string, buffer: Buffer, mimeType: string): void;
    log(format: any, ...args: any[]): void;
}

// @public @deprecated
export function onFinish(f: () => void): void;

// @public
function pending_2(): void;
export { pending_2 as pending }

// Warning: (ae-incompatible-release-tags) The symbol "step" is marked as @public, but its signature references "StepDefName" which is marked as @internal
//
// @public @deprecated
export function step<X>(name: StepDefName, f: () => X): X;

// Warning: (ae-internal-missing-underscore) The name "StepDefName" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export type StepDefName = StepName | string;

// Warning: (ae-internal-missing-underscore) The name "StepName" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export class StepName {
    constructor(parts: string[], placeholders: string[]);
    // (undocumented)
    parts: string[];
    // (undocumented)
    placeholders: string[];
    // (undocumented)
    toString(): string;
}

// @public
function test_2<X>(name: string, f: () => X): X;

// @public
function test_2(nameParts: TemplateStringsArray, ...substitutions: any[]): <X>(f: () => X) => X;
export { test_2 as test }

// @public (undocumented)
export interface Thenable {
    // (undocumented)
    then(onFulfilled?: ((value: any) => any) | undefined | null, onRejected?: ((reason: any) => any) | undefined | null): Thenable;
}

// @public
export function to<X>(name: string, f: () => X): X;

// @public
export function to(nameParts: TemplateStringsArray, ...substitutions: any[]): <X>(f?: () => X) => X;

```
